package bot

import (
	"encoding/json"
	"fmt"
	"log"
	"strconv"
	"strings"
	"time"

	tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
	"github.com/otaviocarvalho/tramuntana/internal/tmux"
)

// PlanTask represents a single task in a plan generated by Claude.
type PlanTask struct {
	Title    string `json:"title"`
	Body     string `json:"body"`
	Priority int    `json:"priority"`
	After    []int  `json:"after"` // 0-based indices into the plan array
}

// planState holds pending plan approval state for a user.
type planState struct {
	Project   string
	Tasks     []PlanTask
	ChatID    int64
	ThreadID  int
	MessageID int
	CreatedAt time.Time
}

const planTimeout = 30 * time.Minute

// handlePlanCommand is the entry point for /t_plan.
func (b *Bot) handlePlanCommand(msg *tgbotapi.Message) {
	chatID := msg.Chat.ID
	threadID := getThreadID(msg)

	description := strings.TrimSpace(msg.CommandArguments())
	if description == "" {
		b.reply(chatID, threadID, "Describe the feature to decompose into tasks:")
		b.setPendingInput(msg.From.ID, "t_plan", chatID, threadID)
		return
	}

	b.executePlan(msg, description)
}

// executePlanWithDescription is the pending input dispatch target.
func (b *Bot) executePlanWithDescription(msg *tgbotapi.Message, text string) {
	description := strings.TrimSpace(text)
	if description == "" {
		b.reply(msg.Chat.ID, getThreadID(msg), "No description provided.")
		return
	}
	b.executePlan(msg, description)
}

// executePlan resolves project + window, builds prompt, sends to tmux.
func (b *Bot) executePlan(msg *tgbotapi.Message, description string) {
	chatID := msg.Chat.ID
	threadID := getThreadID(msg)
	threadIDStr := strconv.Itoa(threadID)

	project, ok := b.state.GetProject(threadIDStr)
	if !ok {
		b.reply(chatID, threadID, "No project bound. Use /p_bind <name> first.")
		return
	}

	windowID, bound := b.resolveWindow(msg)
	if !bound {
		b.reply(chatID, threadID, "Topic not bound to a session.")
		return
	}

	prompt := buildPlanningPrompt(description, project)

	if err := b.sendPromptToTmux(windowID, prompt); err != nil {
		if tmux.IsWindowDead(err) {
			b.handleDeadWindow(msg, windowID, "")
			return
		}
		log.Printf("Error sending plan prompt to tmux: %v", err)
		b.reply(chatID, threadID, "Error: failed to send prompt.")
		return
	}

	b.reply(chatID, threadID, fmt.Sprintf("Planning tasks for: %s\nWaiting for Claude to respond...", description))
}

// buildPlanningPrompt returns the prompt instructing Claude to output PLAN_JSON.
func buildPlanningPrompt(description, project string) string {
	return fmt.Sprintf(`You are a task decomposition assistant. Break down the following feature request into concrete, actionable tasks for the project "%s".

Feature request: %s

Output your plan as a JSON array with the marker PLAN_JSON: on its own line, followed by the JSON.
Each element: {"title": "...", "body": "...", "priority": N, "after": []}

Rules:
- "title" should be a short imperative description (e.g., "Add operator X to graph tool")
- "body" should contain implementation details, file paths, acceptance criteria
- "priority" should be 1 (highest) to 5 (lowest), based on importance
- "after" is an array of 0-based indices of tasks that must complete before this one (dependencies). Use [] for tasks with no dependencies.
- Order tasks logically — foundational work first
- Keep the plan focused and practical, typically 3-10 tasks

Output ONLY the PLAN_JSON: marker line followed by the JSON array. No other text before or after.`, project, description)
}

// HandlePlanFromMonitor is called by the monitor when it detects a PLAN_JSON: marker.
func (b *Bot) HandlePlanFromMonitor(userID int64, threadID int, chatID int64, planJSON string) {
	var tasks []PlanTask
	if err := json.Unmarshal([]byte(planJSON), &tasks); err != nil {
		log.Printf("Error parsing plan JSON: %v", err)
		b.reply(chatID, threadID, fmt.Sprintf("Error parsing plan: %v", err))
		return
	}

	if len(tasks) == 0 {
		b.reply(chatID, threadID, "Plan is empty — no tasks generated.")
		return
	}

	// Validate after indices
	for i, t := range tasks {
		for _, depIdx := range t.After {
			if depIdx < 0 || depIdx >= len(tasks) || depIdx == i {
				b.reply(chatID, threadID, fmt.Sprintf("Invalid dependency in task %d: after index %d", i, depIdx))
				return
			}
		}
	}

	threadIDStr := strconv.Itoa(threadID)
	project, ok := b.state.GetProject(threadIDStr)
	if !ok {
		b.reply(chatID, threadID, "No project bound — cannot create tasks.")
		return
	}

	b.showPlanApproval(userID, chatID, threadID, project, tasks)
}

// showPlanApproval formats the task list and sends a message with [Approve] [Cancel] buttons.
func (b *Bot) showPlanApproval(userID, chatID int64, threadID int, project string, tasks []PlanTask) {
	var lines []string
	lines = append(lines, fmt.Sprintf("Plan for [%s] — %d tasks:", project, len(tasks)))
	lines = append(lines, "")

	for i, t := range tasks {
		deps := ""
		if len(t.After) > 0 {
			depStrs := make([]string, len(t.After))
			for j, d := range t.After {
				depStrs[j] = fmt.Sprintf("#%d", d+1)
			}
			deps = fmt.Sprintf(" (after %s)", strings.Join(depStrs, ", "))
		}
		lines = append(lines, fmt.Sprintf("%d. [P%d] %s%s", i+1, t.Priority, t.Title, deps))
	}

	kb := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("Approve", "plan_approve"),
			tgbotapi.NewInlineKeyboardButtonData("Cancel", "plan_cancel"),
		),
	)

	sent, err := b.sendMessageWithKeyboard(chatID, threadID, strings.Join(lines, "\n"), kb)
	if err != nil {
		log.Printf("Error sending plan approval: %v", err)
		return
	}

	b.mu.Lock()
	b.planStates[userID] = &planState{
		Project:   project,
		Tasks:     tasks,
		ChatID:    chatID,
		ThreadID:  threadID,
		MessageID: sent.MessageID,
		CreatedAt: time.Now(),
	}
	b.mu.Unlock()
}

// processPlanCallback routes plan_approve / plan_cancel callbacks.
func (b *Bot) processPlanCallback(cq *tgbotapi.CallbackQuery) {
	switch cq.Data {
	case "plan_approve":
		b.handlePlanApprove(cq.From.ID)
	case "plan_cancel":
		b.handlePlanCancel(cq.From.ID)
	}
}

// handlePlanApprove creates all tasks with dependencies.
func (b *Bot) handlePlanApprove(userID int64) {
	b.mu.Lock()
	ps, ok := b.planStates[userID]
	if ok {
		delete(b.planStates, userID)
	}
	b.mu.Unlock()

	if !ok {
		return
	}

	// Check timeout
	if time.Since(ps.CreatedAt) > planTimeout {
		b.editMessageText(ps.ChatID, ps.MessageID, "Plan expired (30 min timeout).")
		return
	}

	// Create tasks, mapping plan indices to created IDs
	createdIDs := make(map[int]string) // plan index → created task ID
	var results []string

	for i, t := range ps.Tasks {
		// Resolve dependency IDs
		var afterIDs []string
		for _, depIdx := range t.After {
			if id, ok := createdIDs[depIdx]; ok {
				afterIDs = append(afterIDs, id)
			}
		}

		result, err := b.minuanoBridge.AddWithDeps(t.Title, ps.Project, t.Body, t.Priority, afterIDs)
		if err != nil {
			log.Printf("Error creating task %d (%s): %v", i, t.Title, err)
			results = append(results, fmt.Sprintf("%d. FAILED: %s — %v", i+1, t.Title, err))
			continue
		}

		createdIDs[i] = result.ID
		results = append(results, fmt.Sprintf("%d. %s — %s", i+1, result.ID, result.Title))
	}

	summary := fmt.Sprintf("Created %d/%d tasks:\n\n%s", len(createdIDs), len(ps.Tasks), strings.Join(results, "\n"))
	b.editMessageText(ps.ChatID, ps.MessageID, summary)
}

// handlePlanCancel cancels the pending plan.
func (b *Bot) handlePlanCancel(userID int64) {
	b.mu.Lock()
	ps, ok := b.planStates[userID]
	if ok {
		delete(b.planStates, userID)
	}
	b.mu.Unlock()

	if !ok {
		return
	}

	b.editMessageText(ps.ChatID, ps.MessageID, "Plan cancelled.")
}
